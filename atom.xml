<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Supreme</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://6324up.xyz/"/>
  <updated>2018-07-20T12:11:32.032Z</updated>
  <id>http://6324up.xyz/</id>
  
  <author>
    <name>周琳</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>iptables</title>
    <link href="http://6324up.xyz//blog/Untitled.html"/>
    <id>http://6324up.xyz//blog/Untitled.html</id>
    <published>2018-07-20T06:20:07.000Z</published>
    <updated>2018-07-20T12:11:32.032Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-Netfilter-Iptables"><a href="#1-Netfilter-Iptables" class="headerlink" title="1.Netfilter/Iptables"></a>1.Netfilter/Iptables</h2><p>通常我们所说的 Linux 防火墙是指 Linux 内核集成的 IP 信息包过滤系统—— Netfilter/iptables 。</p><blockquote><ul><li>Netfilter：主要是由内核模块来实现，工作在内核空间，是 Linux 核心中的一个通用架构。在这个框架上实现包过滤、NAT（网络地址转换）等模块功能，采用这样的模块化设计，使其拥有更好的扩展性和较强的灵活性。</li></ul></blockquote><blockquote><ul><li>Iptables：主要是一个上层的操作工具，工作在用户空间，提供一系列的表（tables）、每个表中有若干链（chain），每条链中由一条或多条规则（rule）组成，这些表包含内核用来控制信息包过滤处理的规则集。但真正执行过滤规则的是 Netfilter ，而 iptables 则是工作在其之上，作为用户的一个编写规则的工具。</li></ul></blockquote><p>如图所示：</p><p> <img src="/images/1135081470275678415-wm.png" alt="“图片描述”"></p><h2 id="2-iptables-的基础知识"><a href="#2-iptables-的基础知识" class="headerlink" title="2 iptables 的基础知识"></a>2 iptables 的基础知识</h2><h3 id="2-1-结构图"><a href="#2-1-结构图" class="headerlink" title="2.1 结构图"></a>2.1 结构图</h3><blockquote><p>Netfilter 所设置的规则是存放在内核中的，而 iptables 通过 Netfilter 放出的内核接口对存放在内核中的 Netfilter 配置表进行修改。</p></blockquote><blockquote><p>我们知道 iptables 是由一系列的表（tables）、每个表中有若干链（chain）以及每条链中由一条或多条规则（rule）组成的，最常用到的就是三表五链。</p></blockquote><p> <img src="/images/1135081470275751536-wm.png" alt="“图片描述”"></p><p>iptables 的结构主要是由 tables、chain 和 target 组成。</p><h4 id="2-1-1-tables"><a href="#2-1-1-tables" class="headerlink" title="2.1.1 tables"></a>2.1.1 tables</h4><table><thead><tr><th style="text-align:center">tables</th><th style="text-align:center">说明</th><th style="text-align:center">支持的链</th></tr></thead><tbody><tr><td style="text-align:center">filter</td><td style="text-align:center">默认的表，包含过滤规则</td><td style="text-align:center">INPUT、FORWARD、OUTPUT</td></tr><tr><td style="text-align:center">NAT</td><td style="text-align:center">包含源、目的地址和端口转换使用的规则</td><td style="text-align:center">PREROUTING、OUTPUT、POSTROUTING</td></tr><tr><td style="text-align:center">mangle</td><td style="text-align:center">设置特殊的数据包路由标志的规则</td><td style="text-align:center">五个链都可以</td></tr><tr><td style="text-align:center">raw</td><td style="text-align:center">实现数据跟踪，是新增的表</td><td style="text-align:center">PREROUTING、OUTPUT</td></tr></tbody></table><p>以上这些表具有一定的优先级顺序：</p><p>filter &lt; NAT &lt; mangle &lt; raw</p><h4 id="2-1-2-chains"><a href="#2-1-2-chains" class="headerlink" title="2.1.2 chains"></a>2.1.2 chains</h4><blockquote><p>每个表中的 chains 不尽相同，而 chains 是 Netfilter 框架中制定来对数据包的 Hook Point，其中 Hook Point 会在一个数据包通过网卡流经系统内核相应位置时对数据包的流向做出一定的修改，在系统上主要存在 5 个 Hook Point 的挂载点，如下。</p></blockquote><table><thead><tr><th style="text-align:center">chains</th><th style="text-align:center">describe</th></tr></thead><tbody><tr><td style="text-align:center">PREROUTING</td><td style="text-align:center">用于路由判断前的规则，如修改目的地址（DNAT）</td></tr><tr><td style="text-align:center">INPUT</td><td style="text-align:center">数据包通过路由计算判断为本地的 Linux 系统则通过此链的检查</td></tr><tr><td style="text-align:center">OUTPUT</td><td style="text-align:center">用来针对所有本地生成的包</td></tr><tr><td style="text-align:center">FORWARD</td><td style="text-align:center">两个网络连接时，用于传递数据包，两个网络间的数据包必须流经该防火墙</td></tr><tr><td style="text-align:center">POSTROUTING</td><td style="text-align:center">用于路由判断后的规则，如修改源地址（SNAT）</td></tr></tbody></table><h4 id="2-1-3-target"><a href="#2-1-3-target" class="headerlink" title="2.1.3 target"></a>2.1.3 target</h4><p>target 中的规则大部分是通用的，当然也有部分是特定使用的，这里列举常用的几种规则，更多的规则大家可以通过使用 man 来查看。</p><table><thead><tr><th style="text-align:center">target</th><th style="text-align:center">describe</th></tr></thead><tbody><tr><td style="text-align:center">ACCEPT</td><td style="text-align:center">满足匹配条件就接受数据包</td></tr><tr><td style="text-align:center">DROP</td><td style="text-align:center">满足匹配条件就丢弃数据包</td></tr><tr><td style="text-align:center">REJECT</td><td style="text-align:center">和 DROP 相似，拦截数据包，并返回错误信息</td></tr><tr><td style="text-align:center">SNAT</td><td style="text-align:center">源网络地址转换</td></tr><tr><td style="text-align:center">DNAT</td><td style="text-align:center">目的网络地址转换</td></tr><tr><td style="text-align:center">MASQUERADE</td><td style="text-align:center">和 SNAT 的作用相同，区别在于它不需要指定 –to-source</td></tr><tr><td style="text-align:center">REDIRECT</td><td style="text-align:center">满足匹配条件就将转发数据包到另一个端口</td></tr><tr><td style="text-align:center">MIRROR</td><td style="text-align:center">颠倒 IP 头部中的源目的地址，然后再转发包</td></tr></tbody></table><h4 id="2-2-表（tables）"><a href="#2-2-表（tables）" class="headerlink" title="2.2 表（tables）"></a>2.2 表（tables）</h4><h4 id="2-2-1-filter-表"><a href="#2-2-1-filter-表" class="headerlink" title="2.2.1 filter 表"></a>2.2.1 filter 表</h4><p>filter 表主要用于对数据包的过滤，是默认的一个表，如果没有指定哪个表，iptables 就默认使用 filter 表来执行所有命令。它是包含了真正的过滤规则。规则链主要是：INPUT、FORWARD、OUTPUT。</p><blockquote><p>filter 表在内核中是调用 iptables_filter 这个模块（模块间相互独立），该模块的初始化在 net/ipv4/netfilter/iptable_filter.c –&gt;iptable_filter_init 中。<br>可以大致查看一下<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">static struct nf_hook_ops ipt_ops[] __read_mostly = &#123;</span><br><span class="line">    <span class="comment"># 这是注册的 INPUT 的链</span></span><br><span class="line">    &#123;</span><br><span class="line">        .hook        = ipt_local_in_hook,</span><br><span class="line">        .owner        = THIS_MODULE,</span><br><span class="line">        .pf        = NFPROTO_IPV4,</span><br><span class="line">        .hooknum    = NF_INET_LOCAL_IN,</span><br><span class="line">        .priority    = NF_IP_PRI_FILTER,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment"># 这是注册的 FORWARD 的链</span></span><br><span class="line">    &#123;</span><br><span class="line">        .hook        = ipt_hook,</span><br><span class="line">        .owner        = THIS_MODULE,</span><br><span class="line">        .pf        = NFPROTO_IPV4,</span><br><span class="line">        .hooknum    = NF_INET_FORWARD,</span><br><span class="line">        .priority    = NF_IP_PRI_FILTER,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment"># 这里注册的是 OUTPUT 的链</span></span><br><span class="line">    &#123;</span><br><span class="line">        .hook        = ipt_local_out_hook,</span><br><span class="line">        .owner        = THIS_MODULE,</span><br><span class="line">        .pf        = NFPROTO_IPV4,</span><br><span class="line">        .hooknum    = NF_INET_LOCAL_OUT,</span><br><span class="line">        .priority    = NF_IP_PRI_FILTER,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p></blockquote><p>最终的调用代码如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/* Returns one of the generic firewall policies, like NF_ACCEPT. */</span><br><span class="line">unsigned int</span><br><span class="line">ipt_do_table(struct sk_buff *skb,</span><br><span class="line">         unsigned int hook,</span><br><span class="line">         const struct net_device *<span class="keyword">in</span>,</span><br><span class="line">         const struct net_device *out,</span><br><span class="line">         struct xt_table *table)</span><br></pre></td></tr></table></figure></p><p>以上只是说明了 filter 在初始化时注册的三个 Hook point</p><h4 id="2-2-2-NAT-表"><a href="#2-2-2-NAT-表" class="headerlink" title="2.2.2 NAT 表"></a>2.2.2 NAT 表</h4><blockquote><p>NAT 表（Network Address Translation，网络地址转换）：就是一种将内部网络的 IP 地址转换为合法的公网 IP 地址的技术。主要是修改数据包报头的 IP 地址、端口号等信息，实现数据包的伪装、平衡负载、端口转发以及透明代理。</p></blockquote><p>规则链主要是：PREROUTING 链、OUTPUT 链、POSTROUTING 链。</p><blockquote></blockquote><p>NAT 主要有三种类型：</p><blockquote><ul><li>静态 NAT（static NAT）：IP 地址在转换时是一对一的关系。</li><li>动态 NAT（dynamic NAT 或者叫 pooled NAT）： IP 地址在转换时是多对多的关系。</li><li>NAPT（Network Address Port Translation）：网络地址端口转换在 IP 地址的层面上是多对一的关系。<br>NAPT 是使用较为普遍的转换方式，还可以细分为：</li><li>源 NAT（Source NAT，SNAT）：修改数据包的源地址。源 NAT 改变数据流的第一个数据包的来源地址，数据包伪装就是一个 SNAT 的例子。</li><li>SNAT：若数据包是被送往 POSTROUTING 链的，同时匹配了规则，则执行 SNAT 或 MASQUERADE 目标。系统在决定了数据包的路由之后就执行该链中的规则。</li><li>目的 NAT（DNAT，Destination NAT）：修改数据包的目的地址。它是改变第一个数据包的目的地址，如平衡负载、端口转发和透明代理就是属于 DNAT。</li><li>DNAT：若数据包是被送往 PREROUTING 链，并匹配了规则，则执行 DNAT 或 REDIRECT 目标。为了使数据包得到正确路由，必须在路由之前进行 DNAT。</li></ul></blockquote><p>工作原理</p><p>Nat 的初始化工作和 filter 基本一样。Nat 的 ipv4 部分在 Iptables_nat.c 、Core 部分在 nf_nat_core.c，不同的就是表不一样。<br>先看一下 IP 包的结构，如下图：</p><p><img src="/images/wm.png" alt="“图片描述”"></p><blockquote><p>在 IP 数据包中，都会有源地址（Source ip address）和目的地址（Destination ip address）两个字段，数据包经过的路由器就是根据这两个字段来判定数据包由什么地方发过来，该发往何处。</p></blockquote><p>iptables 中的 DNAT 和 SNAT 的原理和这个类似，下图是可靠数据包在 iptables 中经过的链（chains）：</p><p><img src="/images/wmk.png" alt="“图片描述”"></p><blockquote><p>如图所示，图中的菱形部分就是对数据包进行判定转发的地方。如果目的地址是本机地址，数据被转交给 INPUT 链，反之转交给 FORWARD 链。</p></blockquote><p>举例</p><p>例如，做 DNAT 就是在 PREROUTING 链中，把访问 192.168.42.1 的访问转发到 192.168.0.2 上：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -t nat -A PREROUTING -d 192.168.42.1 -j DNAT --to-destination 192.168.0.2</span><br></pre></td></tr></table></figure></p><p>而 SNAT 是在数据包流出这台机器之前在 POSTROUTING 链进行操作。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -t nat -A POSTROUTING -s 192.168.0.0/24 -j SNAT --to-source 192.168.42.3</span><br></pre></td></tr></table></figure></p><blockquote><p>这个语句就是告诉系统把即将要流出本机的数据的 source ip address 修改成为 192.168.42.3。这样，数据包在达到目的机器以后，目的机器会将包返回到 192.168.42.3 也就是本机。如果不做这个操作，那么你的数据包在传递的过程中，reply 的包肯定会丢失。</p></blockquote><h4 id="2-2-3-mangle-表"><a href="#2-2-3-mangle-表" class="headerlink" title="2.2.3 mangle 表"></a>2.2.3 mangle 表</h4><blockquote><ul><li>mangle 表：主要用于修改数据包的 TOS（Type Of Service，服务类型，根据不同的服务质量来选择经过路由的路径）、TTL（Time To Live，生存周期，每经过一个路由器将减 1，mangle 可以修改此值设定 TTL 要被增加的值，这个选项可以使我们的防火墙更加隐蔽，而不被 trace-routes 发现等等）以及为数据包设置 Mark 标记（特殊标记，用来做高级路由，以使不同的包能使用不同的队列要求等等），Qos(Quality Of Service，服务质量)调整以及策略路由等应用，由于 TOS，Qos 类似的方式需要相应的路由设备支持，所以应用并不广泛。（这里不做过多的讲解）</li></ul></blockquote><p>这个表中包含五个规则链：PREROUTING，POSTROUTING，INPUT，OUTPUT，FORWARD。</p><h4 id="2-2-4-raw-表"><a href="#2-2-4-raw-表" class="headerlink" title="2.2.4 raw 表"></a>2.2.4 raw 表</h4><ul><li>raw 表： 是自 1.2.9 版本以后 iptables 新增的表，主要用于决定数据包是否被状态跟踪机制处理。在匹配数据包时，raw 表的规则要优先于其他表。 包含两条规则链：OUTPUT、PREROUTING。</li></ul><h4 id="2-3-iptables-的状态（status）"><a href="#2-3-iptables-的状态（status）" class="headerlink" title="2.3 iptables 的状态（status）"></a>2.3 iptables 的状态（status）</h4><p>iptables 中数据包被跟踪连接有 4 种不同状态：</p><blockquote><ul><li>NEW ：数据包开始一个新连接（重新连接或将连接重定向）</li><li>RELATED ：数据包是基于某个已经建立的连接而建立的新连接。</li><li>ESTABLISHED ：只要发送并接到应答，一个数据连接就从 NEW 变为 ESTABLISHED ，而且该状态会继续匹配这个连接的后续数据包。</li><li>INVALID ：数据包不能被识别属于哪个连接或没有任何状态的，比如内存溢出，收到不知属于哪个连接的 ICMP 错误信息，一般会 DROP 这个状态的任何数据。</li></ul></blockquote><h2 id="3-iptables-的基本语法"><a href="#3-iptables-的基本语法" class="headerlink" title="3 iptables 的基本语法"></a>3 iptables 的基本语法</h2><h4 id="3-1-语法格式"><a href="#3-1-语法格式" class="headerlink" title="3.1 语法格式"></a>3.1 语法格式</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables [-t tables] COMMAD chains CRETIRIA -j target</span><br></pre></td></tr></table></figure><p>说明：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-t table ：4 个 tables：filter、nat、mangle、raw</span><br></pre></td></tr></table></figure></p><blockquote><ul><li>COMMAND：执行操作</li><li>chain：定义规则在链上的操作</li><li>CRETIRIA：指定匹配标准</li><li>-j target：指定进行数据包处理方式</li></ul></blockquote><p>iptables 的语法规则比较详细，在书写时一定要规范，每个参数都要明确！</p><h4 id="3-2-常用-COMMAND"><a href="#3-2-常用-COMMAND" class="headerlink" title="3.2 常用 COMMAND"></a>3.2 常用 COMMAND</h4><p>COMMAND    describe</p><blockquote><ul><li>-A    新增规则，在当前链的最后新增一个规则</li><li>-I    插入规则，把当前规则插入为第几条，默认插入规则首部</li><li>-R    替换/修改第几条规则</li><li>-D    删除第几条规则</li><li>-P    设置默认策略</li><li>-L    显示指定表和指定链的规则</li></ul></blockquote><p>举例：清除已有 iptables 规则<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 清除规则链中已有的条目</span></span><br><span class="line">$ iptables -F</span><br></pre></td></tr></table></figure></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 清除用户自定义的空链</span></span><br><span class="line">$ iptables -X</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 清空链和链中默认规则的计数器</span></span><br><span class="line">$ iptables -Z</span><br></pre></td></tr></table></figure><h4 id="3-3-CRETIRIA"><a href="#3-3-CRETIRIA" class="headerlink" title="3.3 CRETIRIA"></a>3.3 CRETIRIA</h4><table><thead><tr><th style="text-align:center">CRETIRIA</th><th style="text-align:center">describe</th></tr></thead><tbody><tr><td style="text-align:center">-i</td><td style="text-align:center">数据包进入本机的网络接口</td></tr><tr><td style="text-align:center">-o</td><td style="text-align:center">数据包离开本机的网络接口</td></tr><tr><td style="text-align:center">-p</td><td style="text-align:center">匹配数据包的协议类型</td></tr><tr><td style="text-align:center">-s</td><td style="text-align:center">匹配数据包源 IP 地址</td></tr><tr><td style="text-align:center">-d</td><td style="text-align:center">匹配数据包目的 IP 地址</td></tr><tr><td style="text-align:center">-j</td><td style="text-align:center">指定跳转的目标</td></tr><tr><td style="text-align:center">–sport</td><td style="text-align:center">源端口号</td></tr><tr><td style="text-align:center">–dport</td><td style="text-align:center">目标端口号</td></tr></tbody></table><p>iptables命令选项输入顺序：</p><p>iptables -t 表名 &lt;-A/I/D/R&gt; 规则链名 [规则号] &lt;-i/o 网卡名&gt; -p 协议名 &lt;-s 源IP/源子网&gt; –sport 源端口 &lt;-d 目标IP/目标子网&gt; –dport 目标端口 -j 动作</p><h2 id="4-iptables-的运用"><a href="#4-iptables-的运用" class="headerlink" title="4 iptables 的运用"></a>4 iptables 的运用</h2><h4 id="4-1-查看当前-iptables-的规则"><a href="#4-1-查看当前-iptables-的规则" class="headerlink" title="4.1 查看当前 iptables 的规则"></a>4.1 查看当前 iptables 的规则</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo iptables -nL</span><br></pre></td></tr></table></figure><p><img src="/images/wml.png" alt="“图片描述”"><br>因为该环境下还未设置 iptables 的规则，所以看到的是一个空的。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo iptables -nvL --line</span><br></pre></td></tr></table></figure></p><p><img src="/images/wmo.png" alt="“图片描述”"></p><blockquote><ul><li>第一列： num 显示了该规则在该链中的顺序位置</li><li>第二列： target 显示了该规则所做的行为</li><li>第三列： port 匹配的端口</li><li>第四列： opt 是 TCP 协议头部中 options 的一部分，并不是重点，我们可以不必关注</li><li>第五列、第六列： source、destination 表示对包中分析得出的数据源地址与数据的目的地址的匹配</li></ul></blockquote><h4 id="4-2-实例一"><a href="#4-2-实例一" class="headerlink" title="4.2 实例一"></a>4.2 实例一</h4><p>规则：</p><blockquote><ul><li>对所有地址开放本机的 TCP （80，22，1-20）端口</li><li>允许所有地址开放本机基于 ICMP 协议的数据包</li></ul></blockquote><p>设置规则：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sudo iptables -I INPUT -p tcp --dport 80 -j ACCEPT</span><br><span class="line"></span><br><span class="line">sudo iptables -I INPUT 2 -p tcp --dport 22 -j ACCEPT</span><br><span class="line"></span><br><span class="line">sudo iptables -I INPUT 3 -p tcp --dport 1:20 -j ACCEPT</span><br><span class="line"></span><br><span class="line">sudo iptables -I INPUT 4 -p icmp -j ACCEPT</span><br></pre></td></tr></table></figure></p><p>验证查看规则<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo iptables -L</span><br></pre></td></tr></table></figure></p><p>从输出可看到我们添加的规则已经写入了 iptables 的规则中。</p><h4 id="4-3-实例二"><a href="#4-3-实例二" class="headerlink" title="4.3 实例二"></a>4.3 实例二</h4><p>下面这个例子是将所有访问 80 端口的数据包都丢掉。</p><p>实验准备</p><p>验证 80 端口的开放性<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo netstat -lunpt | grep 80</span><br></pre></td></tr></table></figure></p><p><img src="/images/QQ图片20180720145731.png" alt="“图片描述”"></p><p>可以看到 80 端口已经开放。</p><p>尝试查看能否访问该页面，若返回值为 200 则为成功访问，说明80 端口是可以连接的。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -I localhost</span><br></pre></td></tr></table></figure></p><p><img src="/images/QQ图片20180720145753.png" alt="“图片描述”"><br>添加规则<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 将所有访问 80 端口的数据包都丢掉</span><br><span class="line">sudo iptables -t filter -I INPUT -p tcp --dport 80 -j DROP</span><br></pre></td></tr></table></figure></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 只是查看 INPUT 链是否加入了这条规则</span></span><br><span class="line">sudo iptables -nvL INPUT</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 再来尝试，能否查看到输出信息</span></span><br><span class="line">curl localhost</span><br></pre></td></tr></table></figure><p><img src="/images/zl.png" alt="“图片描述”"></p><p>从截图可以看到没返回，这是因为 DROP 将所有来访问该页面的数据包丢掉，不给任何返回和响应，而 curl 一直等待着服务端的响应。</p><p>若将 DROP 行为改成 REJECT 的话，就会有返回信息说这个端口无法访问。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 删除之前添加的规则，这里没有添加 `-t` 的参数</span></span><br><span class="line"><span class="comment"># 是因为不指明该参数，系统默认为修改指向 filter 表</span></span><br><span class="line">sudo iptables -D INPUT -p tcp --dport 80 -j DROP</span><br><span class="line"></span><br><span class="line"><span class="comment">#也可以使用行号删除</span></span><br><span class="line">sudo iptables -nL --line</span><br><span class="line">sudo iptables -D INPUT 1</span><br><span class="line"></span><br><span class="line"><span class="comment">#添加拒绝的规则</span></span><br><span class="line">sudo iptables -I INPUT -p tcp --dport 80 -j REJECT</span><br><span class="line"></span><br><span class="line"><span class="comment">#再次验证</span></span><br><span class="line">curl -I localhost</span><br></pre></td></tr></table></figure></p><p><img src="/images/QQ图片20180720161646.png" alt="“图片描述”"><br>通过上面的例子可以看到 iptables 已经修改就会立即生效。</p><p>还可以通过另一种方式来查看已经生效的规则，这种方式查看的是直接插入的规则：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo iptables-save</span><br></pre></td></tr></table></figure></p><p>当然 iptables-save 有一个参数 -t 可以指定要保存的表，使用重定向可以将输出保存到某个文件中。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#在执行该命令之前请先用sudo su 切换到 root 用户</span></span><br><span class="line"></span><br><span class="line">sudo iptables-save -t filter &gt; filter.bak</span><br><span class="line"></span><br><span class="line">cat filter.bak</span><br></pre></td></tr></table></figure></p><p><img src="/images/zli.png" alt="“图片描述”"><br>另外，还有一个 iptables-restore 命令可以将保存到文件中的规则重新恢复到系统中。</p><h4 id="4-4-实例三"><a href="#4-4-实例三" class="headerlink" title="4.4 实例三"></a>4.4 实例三</h4><p>端口转发，将发往80端口的请求转发到9200端口<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># iptables -t nat -A PREROUTING -d 192.168.5.141 -p tcp --dport 80 -j REDIRECT --to-ports 9200</span></span><br><span class="line"></span><br><span class="line">此规则只对外部访问有效，如果是内部访问localhost则无效，因为loopback不走PREROUTING，需要定义OUPUT规则下的转发：</span><br><span class="line">iptables -t nat -I OUTPUT -p tcp -d 127.0.0.1 --dport 80 -j REDIRECT --to-ports 9200</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-Netfilter-Iptables&quot;&gt;&lt;a href=&quot;#1-Netfilter-Iptables&quot; class=&quot;headerlink&quot; title=&quot;1.Netfilter/Iptables&quot;&gt;&lt;/a&gt;1.Netfilter/Iptables&lt;/h2&gt;&lt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>SVN</title>
    <link href="http://6324up.xyz//blog/hello-world.html"/>
    <id>http://6324up.xyz//blog/hello-world.html</id>
    <published>2018-07-18T10:16:00.000Z</published>
    <updated>2018-07-18T10:47:45.214Z</updated>
    
    <content type="html"><![CDATA[<p>一.日常使用手册</p><p>1.创建svn项目<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># svnadmin create /data/svn/newproject        --svn项目：newproject</span></span><br></pre></td></tr></table></figure></p><p>2.创建用户<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># htpasswd /data/svnauth/passwd newuser       --用户：newuser</span></span><br></pre></td></tr></table></figure></p><p>3.配置仓库权限<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># vim /data/svnauth/authz</span></span><br><span class="line">[groups]                               --配置组，用户</span><br><span class="line">develop = test1,test2,testzl           --格式：组 = 用户       多个用户用逗号隔开</span><br><span class="line">android = test3</span><br><span class="line">admin = zhouladmin</span><br><span class="line">dgg = dg</span><br><span class="line">                                       --不同项目之间空一行隔开</span><br><span class="line">[newproject:/]                         --配置svn项目权限</span><br><span class="line">@develop = rw</span><br><span class="line">@admin = rw</span><br><span class="line">* =</span><br></pre></td></tr></table></figure></p><p>注意：使用浏览器登陆仓库后会保存缓存，导致无法登陆其他仓库，清理浏览器缓存即可</p><p>二、部署</p><p>1.安装<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># apt-get -y install subversion apache2 libapache2-svn ssl-cert</span></span><br></pre></td></tr></table></figure></p><p>如果apache相关软件无法安装，则换一个安装源再次安装即可</p><p>更换国内源<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># mv /etc/apt/sources.list /etc/apt/sources.list.bak</span></span><br><span class="line"><span class="comment"># cat &gt; /etc/apt/sources.list &lt;&lt; EOF    </span></span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ trusty main restricted universe multiverse  </span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ trusty-security main restricted universe multiverse  </span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ trusty-updates main restricted universe multiverse  </span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ trusty-proposed main restricted universe multiverse  </span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ trusty-backports main restricted universe multiverse  </span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ trusty main restricted universe multiverse  </span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ trusty-security main restricted universe multiverse  </span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ trusty-updates main restricted universe multiverse  </span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ trusty-proposed main restricted universe multiverse  </span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ trusty-backports main restricted universe multiverse  </span><br><span class="line">EOF</span><br><span class="line"><span class="comment"># apt-get update</span></span><br></pre></td></tr></table></figure></p><p>查看安装版本<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># svn –version</span></span><br><span class="line">svn, version 1.8.8 (r1568071)</span><br><span class="line">   compiled Aug 10 2017, 17:20:39 on x86_64-pc-linux-gnu</span><br></pre></td></tr></table></figure></p><p>  2.配置</p><p>2.1svn仓库基本配置</p><p>创建svn仓库存储路径<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># mkdir -p /data/svn</span></span><br></pre></td></tr></table></figure></p><p>修改/data目录属性</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># chown -R www-data:www-data /data/</span></span><br><span class="line"><span class="comment"># chmod 755 -R /data/</span></span><br></pre></td></tr></table></figure><p>2.2创建svn仓库<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># svnadmin create /data/svn/devroot         --仓库名：devroot</span></span><br></pre></td></tr></table></figure></p><p>2.3svn仓库权限配置</p><p>svn仓库权限，可以进行单独配置，也可以进行统一配置。考虑实际情况，一般会有多个svn仓库，这里采用统一配置。</p><p>创建用于管理所有仓库帐号密码、权限控制等的目录svnauth<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># mkdir -p /data/svnauth/</span></span><br></pre></td></tr></table></figure></p><p>创建svn仓库权限的总控制文件svnserve.conf<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># vim /data/svnauth/svnserve.conf</span></span><br><span class="line">[general]</span><br><span class="line"><span class="comment">#未鉴定的用户无权限访问该版本库</span></span><br><span class="line">anon-access = none</span><br><span class="line"></span><br><span class="line"><span class="comment">#鉴定后的可读写版本库</span></span><br><span class="line">auth-access = write</span><br><span class="line"></span><br><span class="line"><span class="comment">#使用的密码文件是同级路径的passwd文件，即是/data/svnaut/passwd</span></span><br><span class="line">password-db = passwd</span><br><span class="line"></span><br><span class="line"><span class="comment">#使用的权限控制文件是同级路径的authz文件，即是/data/svndauth/authz</span></span><br><span class="line">authz-db = authz</span><br><span class="line"></span><br><span class="line"><span class="comment">#realm指定版本库的认证域，即在登录时提示的认证域名称。各个仓库的认证域都可以自定义</span></span><br><span class="line">realm = svnauth</span><br></pre></td></tr></table></figure></p><p><img src="/images/1531724442366.jpg" alt="“图片描述”"></p><p>创建passwd文件<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># touch /data/svnauth/passwd</span></span><br></pre></td></tr></table></figure></p><p>创建authz文件<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># vim /data/svndata/authz</span></span><br><span class="line">[groups]             //用户组配置</span><br><span class="line">develop = test1,test2,testzl           //定义develop用户组成员test1,test2,testzl</span><br><span class="line">android = test3</span><br><span class="line">admin = zhouladmin</span><br><span class="line">dgg = dg</span><br><span class="line"></span><br><span class="line">[devroot:/]                     //仓库权限配置，仓库名：devroot</span><br><span class="line">@develop = rw                    //develop用户组具有读（r）写(w)权限</span><br><span class="line">@admin = rw</span><br><span class="line">* =                          //其他用户和组没有访问权限</span><br></pre></td></tr></table></figure></p><p><img src="/images/1531725835361.jpg" alt="“图片描述”"></p><p>2.4配置访问方式（此处为https）</p><p>配置apache2<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># vim /etc/apache2/mods-available/dav_svn.conf</span></span><br><span class="line">&lt;Location /repos&gt;</span><br><span class="line">   DAV svn</span><br><span class="line">   SVNParentPath /data/svn</span><br><span class="line">   AuthzSVNAccessFile /data/svnauth/authz</span><br><span class="line">   AuthType Basic</span><br><span class="line">   AuthName <span class="string">"Authorization Realm"</span></span><br><span class="line">   AuthUserFile /data/svnauth/passwd</span><br><span class="line">   Require valid-user</span><br><span class="line">   SSLRequireSSL</span><br><span class="line">&lt;/Location&gt;</span><br></pre></td></tr></table></figure></p><p>启用ssl模块<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># a2enmod ssl</span></span><br></pre></td></tr></table></figure></p><p>如果没有a2enmod指令，也可直接在apache2.conf中设置SSL模块加载，如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LoadModule ssl_module /usr/lib/apache2/modules/mod_ssl.so</span><br></pre></td></tr></table></figure></p><p>启用SSL站点<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># a2ensite default-ssl</span></span><br></pre></td></tr></table></figure></p><p>重启apache<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># service apache2 restart</span></span><br></pre></td></tr></table></figure></p><p>2.5设置svn的用户和密码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># htpasswd -cm /data/svnauth/passwd testzl      --创建用户：testzl</span></span><br></pre></td></tr></table></figure><p>配置用户权限</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># vim /data/svnauth/authz           --配置testzl的组和访问svn仓库的权限</span></span><br></pre></td></tr></table></figure><p><img src="/images/1531726817825.jpg" alt="“图片描述”"></p><p>3.访问测试</p><p>浏览器输入：<a href="https://IP/repos/devroot" target="_blank" rel="noopener">https://IP/repos/devroot</a></p><p><img src="/images/1531726675853.jpg" alt="“图片描述”"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一.日常使用手册&lt;/p&gt;
&lt;p&gt;1.创建svn项目&lt;br&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>rabbitmq添加虚拟主机</title>
    <link href="http://6324up.xyz//blog/Plan.html"/>
    <id>http://6324up.xyz//blog/Plan.html</id>
    <published>2018-03-08T08:27:00.000Z</published>
    <updated>2018-07-18T10:15:38.606Z</updated>
    
    <content type="html"><![CDATA[<p>创建用户（如果没有的话）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># rabbitmqctl  add_user test 123456                 --用户：test，密码：123456</span></span><br></pre></td></tr></table></figure><p>创建虚拟主机<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># rabbitmqctl add_vhost test_host                   --虚拟主机名：test_host</span></span><br></pre></td></tr></table></figure></p><p>查看虚拟主机列表<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># rabbitmqctl list_vhosts</span></span><br></pre></td></tr></table></figure></p><p>配置用户权限（此处为读写权限）<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># rabbitmqctl set_permissions -p test_host  test ".*" ".*" ".*"         --用户test对test_host虚拟主机具有读写权限</span></span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;创建用户（如果没有的话）&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;c
      
    
    </summary>
    
    
  </entry>
  
</feed>
